Sort a linked list in O(n log n) time using constant space complexity.

Example 1:
```
Input: 4->2->1->3
Output: 1->2->3->4
```
Example 2:
```
Input: -1->5->3->4->0
Output: -1->0->3->4->5
```
**题意：**
判断一个链表是否有环，有环的话返回环的起始节点，无环的话返回NULL。




**解法一：** 使用Hashset保存节点，然后遍历，但是这样效率极低。

> 运行结果（通过）： Runtime: 15 ms, faster than 4.29% of Java online submissions for Linked List Cycle II.

**解法二：** Linked List Cycle的升级，不仅要判断有无环，还要求入口。很显然可以在Linked List Cycle的基础上来做。

这里我直接翻译ngcl的answer，写得非常好：

用slower和faster方法判断是否有环；
设链表的头节点是head，环的入口节点是entry，slower和faster2个指针相遇的节点是meeting;
设L1是head到entry的正向距离，L2是entry到meeting的正向距离，C是环的长度，n是faster指针在cycle里遍历的次数(不到一遍算0)；
根据上面的定义，可知：

当slower和faster相遇时，slower已经走了L1 + L2的距离，也即head和meeting的距离;
当slower和faster相遇时，faster已经走了L1 + L2 + n * C的距离;
因为slower步进1，而faster步进2，那么当slower和faster第一次相遇时，faster已经走的距离是slower已经走的距离的两倍，即 2* (L1 + L2) = L1 + L2 + n * C => L1 = (n - 1) * C + (C - L2)
L1 = (n - 1) * C + (C - L2) 这个等式表明， head和entry的距离(L1)，等于meeting到entry的正向距离（链表是有遍历方向的）。

这是因为式子中的 (n - 1) * C相当于走n-1个循环，对一个指向meeting的环内指针来说，走(n - 1) * C等于回到起点，所以式子可以简化成 L1 = C - L2。
![image](https://www.qiujiawei.com/images/2015.7/2.png)
```Java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null)
            return null;
        
        ListNode fastNode = head;
        ListNode slowNode = head;
        
        while(fastNode != null && fastNode.next != null){
            
            fastNode = fastNode.next.next;
            slowNode = slowNode.next;
            
            if(fastNode == slowNode){
                
                slowNode = head;
                
                while(slowNode != fastNode){
                    slowNode = slowNode.next;
                    fastNode = fastNode.next;
                }
                
                return slowNode;
                
            }
        }
        return null;    
    }
}
```
> Runtime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle II.